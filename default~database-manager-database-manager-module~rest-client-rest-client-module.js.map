{"version":3,"sources":["./node_modules/@ngrx/effects/fesm5/effects.js","./node_modules/@ngrx/store-devtools/fesm5/store-devtools.js","./node_modules/@ngrx/store/fesm5/store.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACiG;AACQ;AAClC;AACkF;AACpD;;AAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAQ,EAAE,2CAA2C;AACrE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,sDAAQ,EAAE,6BAA6B;AACtD,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sDAAQ,8CAA8C,UAAU;AACtF;AACA,sCAAsC;AACtC;AACA;AACA,mBAAmB,QAAQ,gBAAgB;AAC3C;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yCAAyC,EAAE;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAU;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wCAAwC,qEAAc;AACtD;AACA,iDAAiD,kEAAW;AAC5D,kCAAkC,0DAAG,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE,EAAE;AACb,KAAK;AACL,WAAW,0CAAK,eAAe,sDAAQ;AACvC;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAU;AACpC,QAAQ,gEAAU;AAClB,QAAQ,qDAAO,IAAI,4DAAM,CAAC,iEAAqB;AAC/C,QAAQ,wDAAU,uBAAuB,+CAAU;AACnD;AACA;AACA,CAAC,CAAC,+CAAU;AACZ;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,WAAW,6DAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAO,wBAAwB,+DAAQ,qBAAqB,qBAAqB,8DAAO,mBAAmB,EAAE,GAAG,+DAAQ;AACjJ,gCAAgC,iEAAU,2CAA2C,0DAAG;AACxF;AACA;AACA,aAAa,GAAG,6DAAM;AACtB;AACA,aAAa,GAAG,oEAAa;AAC7B,SAAS;AACT;AACA,oBAAoB,wDAAU;AAC9B,QAAQ,gEAAU;AAClB,QAAQ,wDAAU,uBAAuB,0DAAY,EAAE,iDAAK;AAC5D;AACA;AACA,CAAC,CAAC,4CAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,4DAAc;AAC1C,uBAAuB,4DAAc;AACrC,0BAA0B,4DAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B,QAAQ,gEAAU;AAClB,QAAQ,wDAAU;AAClB,YAAY,iDAAK;AACjB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA,wBAAwB,wDAAU;AAClC,QAAQ,8DAAQ,GAAG;AACnB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,qDAAO,IAAI,8DAAQ;AAC3B,QAAQ,qDAAO,IAAI,8DAAQ;AAC3B,QAAQ,wDAAU;AAClB;AACA,YAAY,iDAAK,SAAS,2DAAe;AACzC,YAAY,8DAAkB;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,2BAA2B,wDAAU;AACrC,QAAQ,8DAAQ,GAAG;AACnB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,qDAAO,IAAI,8DAAQ;AAC3B,QAAQ,qDAAO,IAAI,8DAAQ;AAC3B,QAAQ,wDAAU,iDAAiD,2DAAe;AAClF,YAAY,8DAAkB;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B,QAAQ,8DAAQ,GAAG;AACnB;AACA;AACA,CAAC;AACD;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAS;AAC/B;AACA;AACA;AACA,UAAU,sDAAQ,GAAG,oBAAoB,uCAAuC,wDAAS,EAAE;AAC3F;AACA,eAAe,kDAAK;AACpB,8BAA8B,4CAAO;AACrC,mBAAmB,kDAAK;AACxB,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA,sDAAsD,kEAAW,IAAI,0DAAG;AACxE;AACA;AACA;AACA,2CAA2C,iDAAY;AACvD;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,GAAG,6DAAM,eAAe,kBAAkB,EAAE,GAAG,oEAAa,IAAI,+DAAQ;AAC7F;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEyc;AACzc;;;;;;;;;;;;;ACzdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAC+F;AACJ;AACoE;AAC5E;AACkF;;AAErK;AACA;AACA;AACA;AACA,CAAC;AACD,gCAAgC,4DAAc;AAC9C,0BAA0B,4DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,iCAAiC,oBAAoB,qBAAqB;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,yCAAyC,iCAAiC,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,sDAAQ,GAAG,WAAW,oDAAoD;AACrF;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,KAAK,EAAE,EAAE;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,sDAAQ,GAAG,gBAAgB,qHAAqH;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA,yBAAyB,wDAAU;AACnC,QAAQ,gEAAU;AAClB;AACA;AACA,CAAC,CAAC,0DAAc;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yCAAyC,sDAAQ,GAAG,UAAU;AAC9D;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB;AACA,mBAAmB,+CAAU;AAC7B;AACA;AACA;AACA,oDAAoD,gCAAgC,EAAE;AACtF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2DAA2D,4DAAK;AAChE;AACA,mCAAmC,6DAAM,oBAAoB,mDAAmD,EAAE;AAClH;AACA,kCAAkC,6DAAM,oBAAoB,kDAAkD,EAAE;AAChH;AACA,2CAA2C,6DAAM,oBAAoB,sDAAsD,EAAE,GAAG,0DAAG,oBAAoB,2CAA2C,EAAE,GAAG,gEAAS;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAM,oBAAoB,wBAAwB,kDAAM,CAAC,EAAE,GAAG,8DAAO,QAAQ,mEAAY,QAAQ,0DAAG,cAAc,eAAe,EAAE,GAAG,iEAAU,cAAc,QAAQ,+CAAE,SAAS,EAAE,GAAG,2DAAI;AACvO;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA,SAAS;AACT;AACA,qCAAqC,6DAAM,oBAAoB,oDAAoD,EAAE,GAAG,0DAAG,oBAAoB,2CAA2C,EAAE;AAC5L,8CAA8C,gEAAS;AACvD,mDAAmD,gEAAS;AAC5D,kCAAkC,gEAAS;AAC3C;AACA,yCAAyC,gEAAS,cAAc,0BAA0B,EAAE;AAC5F,+CAA+C,gEAAS,cAAc,yBAAyB,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAU;AAClC,QAAQ,gEAAU;AAClB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,wDAAU;AAClB;AACA;AACA;AACA,CAAC;;AAED,mBAAmB,OAAO,gDAAI;AAC9B;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uCAAuC,EAAE;AAC/G,8BAA8B,sDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAQ;AAC9C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sDAAQ;AAC/C;AACA;AACA,8EAA8E,0BAA0B,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,uCAAuC,sDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sDAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAM;AACvB,6EAA6E,oBAAoB,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAQ;AAClD;AACA;AACA;AACA;AACA,wEAAwE,SAAS,sDAAQ,GAAG,QAAQ,8CAA8C,GAAG,EAAE;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAK,CAAC,kDAAK,8BAA8B,2DAAI,+BAA+B,0DAAG,0DAA0D,gEAAS,CAAC,mDAAc;AAC7L,4CAA4C,0DAAG;AAC/C,qCAAqC,kDAAa;AAClD;AACA,kBAAkB,qEAAc,kBAAkB,2DAAI;AACtD;AACA,qBAAqB,oDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS,GAAG,0CAA0C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,uCAAuC,0DAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B,QAAQ,gEAAU;AAClB,QAAQ,qDAAO,IAAI,4DAAM,CAAC,yDAAa;AACvC,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,wDAAU;AAClB,YAAY,0DAAc;AAC1B,YAAY,6DAAiB;AAC7B;AACA,YAAY,iEAAqB;AACjC,YAAY,0DAAY;AACxB;AACA;AACA,CAAC;;AAED,0CAA0C,4DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B,2DAAe;AAC5C;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B,oEAAwB;AACrD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kDAAkD,wDAAU;AAC5D,QAAQ,8DAAQ,GAAG;AACnB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEo2B;AACp2B;;;;;;;;;;;;;ACt6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACyG;AACP;AACtB;AACuB;;AAEnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,2CAA2C;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO,OAAO,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA,oBAAoB,sDAAQ,GAAG,uBAAuB,sDAAQ,UAAU,aAAa;AACrF,SAAS;AACT;AACA;AACA;AACA;AACA,iDAAiD,UAAU,aAAa,EAAE,EAAE;AAC5E;AACA,sDAAsD,SAAS,sDAAQ,GAAG,UAAU,aAAa,GAAG,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI,uDAAS;AACb;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAU;AAC/B,QAAQ,gEAAU;AAClB,QAAQ,wDAAU;AAClB;AACA;AACA,CAAC,CAAC,oDAAe;AACjB;;AAEA,yBAAyB,4DAAc;AACvC,wBAAwB,4DAAc;AACtC,0BAA0B,4DAAc;AACxC,2BAA2B,4DAAc;AACzC,2BAA2B,4DAAc;AACzC,4BAA4B,4DAAc;AAC1C,yBAAyB,4DAAc;AACvC,0BAA0B,4DAAc;AACxC,4BAA4B,4DAAc;AAC1C,2BAA2B,4DAAc;AACzC,0BAA0B,4DAAc;AACxC,kCAAkC,4DAAc;AAChD,2BAA2B,4DAAc;AACzC;AACA;AACA;AACA,sCAAsC,4DAAc;AACpD;AACA;AACA;AACA,wBAAwB,4DAAc;AACtC;AACA;AACA;AACA;AACA,kCAAkC,4DAAc;AAChD;AACA;AACA;AACA;AACA,8BAA8B,4DAAc;AAC5C;AACA;AACA;AACA,+BAA+B,4DAAc;AAC7C;AACA;AACA;AACA,iCAAiC,4DAAc;;AAE/C;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4BAA4B,EAAE;AAC9D;AACA;AACA,6CAA6C;AAC7C,KAAK,IAAI;AACT;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB,EAAE;AAChF;AACA;AACA;AACA;AACA,6CAA6C,sDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAQ,gCAAgC,UAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA,CAAC,CAAC,+CAAU;AACZ;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc,EAAE;AACvE;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,wBAAwB,sDAAQ,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,wDAAU;AAC/B,QAAQ,gEAAU;AAClB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,wDAAU;AAClB;AACA;AACA,CAAC,CAAC,oDAAe;AACjB;AACA;AACA,KAAK,0DAA0D;AAC/D,KAAK,iEAAiE;AACtE;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAU;AACtC,QAAQ,gEAAU;AAClB;AACA;AACA,CAAC,CAAC,4CAAO;AACT;AACA;AACA;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA,CAAC,CAAC,+CAAU;AACZ;AACA,IAAI,uDAAS;AACb;AACA;AACA,4CAA4C,gEAAS,CAAC,mDAAc;AACpE,sDAAsD,qEAAc;AACpE,oBAAoB;AACpB,sDAAsD,2DAAI;AAC1D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAU;AACtB,QAAQ,gEAAU;AAClB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,wDAAU;AAClB;AACA;AACA;AACA;AACA,CAAC,CAAC,oDAAe;AACjB;AACA,qCAAqC,oBAAoB,oBAAoB;AAC7E,aAAa,oDAAM;AACnB;AACA,YAAY;AACZ;AACA;AACA;AACA,KAAK,+CAA+C;AACpD;;AAEA;AACA,IAAI,uDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,yCAAyC,sDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAU;AAChC,QAAQ,gEAAU;AAClB,QAAQ,wDAAU;AAClB;AACA;AACA;AACA;AACA,CAAC,CAAC,+CAAU;AACZ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAQ;AACrC,mCAAmC,oDAAK,eAAe,sDAAQ;AAC/D;AACA;AACA,mCAAmC,0DAAG,oBAAoB,yCAAyC,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAoB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iCAAiC;AACvE,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,+DAA+D,sDAAQ;AACvE;AACA;AACA;AACA,kDAAkD,kBAAkB,EAAE;AACtE;AACA;AACA;AACA;AACA,KAAK;AACL,kDAAkD,sDAAQ;AAC1D;AACA;AACA,6BAA6B;AAC7B;AACA,MAAM;AACN;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,oDAAM;AAC3B,mBAAmB,sDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2DAA2D,2BAA2B,EAAE;AACxF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,2BAA2B,qBAAqB,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sDAAQ;AACpD;AACA;AACA,kBAAkB,sDAAQ;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,+DAAS;AACjB;AACA;AACA;AACA,eAAe,sDAAQ,EAAE,yIAAyI;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,wDAAU;AAChC,QAAQ,8DAAQ,GAAG;AACnB,QAAQ,wDAAU;AAClB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAQ,GAAG,YAAY,+EAA+E;AACzH,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAU;AACnC,QAAQ,8DAAQ,GAAG;AACnB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,qDAAO,IAAI,4DAAM;AACzB,QAAQ,wDAAU;AAClB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,iBAAiB,yDAAyD;AAC1E;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB,iDAAiD;AAClE;AACA;AACA,qDAAqD,4DAAc;AACnE,iBAAiB;AACjB;AACA;AACA,2BAA2B,sDAAQ,0BAA0B,oDAAM;AACnE;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4DAA4D,4DAAc;AAC1E;AACA;AACA,0DAA0D,4DAAc;AACxE;AACA;AACA,0DAA0D,4DAAc;AACxE;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,2BAA2B,sDAAQ;AACnC;AACA,iBAAiB;AACjB,iBAAiB,8DAA8D;AAC/E;AACA;AACA;AACA,qDAAqD,4DAAc;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wBAAwB,sDAAQ;AAChC;AACA,6BAA6B,oDAAM;AACnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,wDAAU;AAC5B,QAAQ,8DAAQ,GAAG;AACnB;AACA;AACA,CAAC;AACD;AACA,+BAA+B,4DAAc;AAC7C;AACA;AACA;AACA,sCAAsC,4DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kCAAkC,4DAAc;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,wDAAwD,QAAQ,sDAAQ,yBAAyB,EAAE;AACnG,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,OAAO,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,yBAAyB,sDAAQ,8BAA8B,eAAe;AAC9E;AACA;AACA,8BAA8B,sDAAQ,6BAA6B,UAAU;AAC7E;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,gBAAgB;AACnD;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA,mBAAmB,QAAQ,gBAAgB;AAC3C;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAE8+D;AAC9+D","file":"default~database-manager-database-manager-module~rest-client-rest-client-module.js","sourcesContent":["/**\n * @license NgRx 8.3.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { __assign, __values, __spread, __extends, __decorate, __param, __metadata } from 'tslib';\nimport { compose, ScannedActionsSubject, Store, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification } from 'rxjs';\nimport { catchError, ignoreElements, materialize, map, filter, groupBy, mergeMap, exhaustMap, dematerialize, concatMap, finalize } from 'rxjs/operators';\nimport { Injectable, Inject, ErrorHandler, InjectionToken, NgModule, Optional } from '@angular/core';\n\nvar CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `resubscribeOnError` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nfunction createEffect(source, config) {\n    var effect = source();\n    // Right now both createEffect and @Effect decorator set default values.\n    // Ideally that should only be done in one place that aggregates that info,\n    // for example in mergeEffects().\n    var value = __assign({ dispatch: true, resubscribeOnError: true }, config);\n    Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n        value: value,\n    });\n    return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n    var propertyNames = Object.getOwnPropertyNames(instance);\n    var metadata = propertyNames\n        .filter(function (propertyName) {\n        return instance[propertyName] &&\n            instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY);\n    })\n        .map(function (propertyName) {\n        var metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n        return __assign({ propertyName: propertyName }, metaData);\n    });\n    return metadata;\n}\n\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\n\nvar METADATA_KEY = '__@ngrx/effects__';\nfunction Effect(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.dispatch, dispatch = _c === void 0 ? true : _c, _d = _b.resubscribeOnError, resubscribeOnError = _d === void 0 ? true : _d;\n    return function (target, propertyName) {\n        // Right now both createEffect and @Effect decorator set default values.\n        // Ideally that should only be done in one place that aggregates that info,\n        // for example in mergeEffects().\n        var metadata = {\n            propertyName: propertyName,\n            dispatch: dispatch,\n            resubscribeOnError: resubscribeOnError,\n        };\n        setEffectMetadataEntries(target, [metadata]);\n    };\n}\nfunction getEffectDecoratorMetadata(instance) {\n    var effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n    return effectsDecorators;\n}\nfunction setEffectMetadataEntries(sourceProto, entries) {\n    var constructor = sourceProto.constructor;\n    var meta = constructor.hasOwnProperty(METADATA_KEY)\n        ? constructor[METADATA_KEY]\n        : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[METADATA_KEY];\n    Array.prototype.push.apply(meta, entries);\n}\nfunction getEffectMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY)\n        ? sourceProto.constructor[METADATA_KEY]\n        : [];\n}\n\nfunction getEffectsMetadata(instance) {\n    var e_1, _a;\n    var metadata = {};\n    try {\n        for (var _b = __values(getSourceMetadata(instance)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = _c.value, propertyName = _d.propertyName, dispatch = _d.dispatch, resubscribeOnError = _d.resubscribeOnError;\n            metadata[propertyName] = { dispatch: dispatch, resubscribeOnError: resubscribeOnError };\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return metadata;\n}\nfunction getSourceMetadata(instance) {\n    var effects = [\n        getEffectDecoratorMetadata,\n        getCreateEffectMetadata,\n    ];\n    return effects.reduce(function (sources, source) { return sources.concat(source(instance)); }, []);\n}\n\nfunction mergeEffects(sourceInstance, errorHandler) {\n    var sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    var observables$ = getSourceMetadata(sourceInstance).map(function (_a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch, resubscribeOnError = _a.resubscribeOnError;\n        var observable$ = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        var resubscribable$ = resubscribeOnError\n            ? observable$.pipe(catchError(function (error) {\n                if (errorHandler)\n                    errorHandler.handleError(error);\n                // Return observable that produces this particular effect\n                return observable$;\n            }))\n            : observable$;\n        if (dispatch === false) {\n            return resubscribable$.pipe(ignoreElements());\n        }\n        var materialized$ = resubscribable$.pipe(materialize());\n        return materialized$.pipe(map(function (notification) { return ({\n            effect: sourceInstance[propertyName],\n            notification: notification,\n            propertyName: propertyName,\n            sourceName: sourceName,\n            sourceInstance: sourceInstance,\n        }); }));\n    });\n    return merge.apply(void 0, __spread(observables$));\n}\n\nvar Actions = /** @class */ (function (_super) {\n    __extends(Actions, _super);\n    function Actions(source) {\n        var _this = _super.call(this) || this;\n        if (source) {\n            _this.source = source;\n        }\n        return _this;\n    }\n    Actions_1 = Actions;\n    Actions.prototype.lift = function (operator) {\n        var observable = new Actions_1();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    var Actions_1;\n    Actions = Actions_1 = __decorate([\n        Injectable(),\n        __param(0, Inject(ScannedActionsSubject)),\n        __metadata(\"design:paramtypes\", [Observable])\n    ], Actions);\n    return Actions;\n}(Observable));\nfunction ofType() {\n    var allowedTypes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        allowedTypes[_i] = arguments[_i];\n    }\n    return filter(function (action) {\n        return allowedTypes.some(function (typeOrActionCreator) {\n            if (typeof typeOrActionCreator === 'string') {\n                // Comparing the string to type\n                return typeOrActionCreator === action.type;\n            }\n            // We are filtering by ActionCreator\n            return typeOrActionCreator.type === action.type;\n        });\n    });\n}\n\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        var action = output.notification.value;\n        var isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(\"Effect \" + getEffectName(output) + \" dispatched an invalid action: \" + stringify(action)));\n        }\n    }\n}\nfunction isAction(action) {\n    return (typeof action !== 'function' &&\n        action &&\n        action.type &&\n        typeof action.type === 'string');\n}\nfunction getEffectName(_a) {\n    var propertyName = _a.propertyName, sourceInstance = _a.sourceInstance, sourceName = _a.sourceName;\n    var isMethod = typeof sourceInstance[propertyName] === 'function';\n    return \"\\\"\" + sourceName + \".\" + propertyName + (isMethod ? '()' : '') + \"\\\"\";\n}\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch (_a) {\n        return action;\n    }\n}\n\nvar onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\nvar onRunEffectsKey = 'ngrxOnRunEffects';\nvar onInitEffects = 'ngrxOnInitEffects';\n\nvar EffectSources = /** @class */ (function (_super) {\n    __extends(EffectSources, _super);\n    function EffectSources(errorHandler, store) {\n        var _this = _super.call(this) || this;\n        _this.errorHandler = errorHandler;\n        _this.store = store;\n        return _this;\n    }\n    EffectSources.prototype.addEffects = function (effectSourceInstance) {\n        this.next(effectSourceInstance);\n        if (onInitEffects in effectSourceInstance &&\n            typeof effectSourceInstance[onInitEffects] === 'function') {\n            this.store.dispatch(effectSourceInstance[onInitEffects]());\n        }\n    };\n    /**\n     * @internal\n     */\n    EffectSources.prototype.toActions = function () {\n        var _this = this;\n        return this.pipe(groupBy(getSourceForInstance), mergeMap(function (source$) { return source$.pipe(groupBy(effectsInstance)); }), mergeMap(function (source$) {\n            return source$.pipe(exhaustMap(resolveEffectSource(_this.errorHandler)), map(function (output) {\n                reportInvalidActions(output, _this.errorHandler);\n                return output.notification;\n            }), filter(function (notification) {\n                return notification.kind === 'N';\n            }), dematerialize());\n        }));\n    };\n    EffectSources = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [ErrorHandler, Store])\n    ], EffectSources);\n    return EffectSources;\n}(Subject));\nfunction effectsInstance(sourceInstance) {\n    if (onIdentifyEffectsKey in sourceInstance &&\n        typeof sourceInstance[onIdentifyEffectsKey] === 'function') {\n        return sourceInstance[onIdentifyEffectsKey]();\n    }\n    return '';\n}\nfunction resolveEffectSource(errorHandler) {\n    return function (sourceInstance) {\n        var mergedEffects$ = mergeEffects(sourceInstance, errorHandler);\n        if (isOnRunEffects(sourceInstance)) {\n            return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n        }\n        return mergedEffects$;\n    };\n}\nfunction isOnRunEffects(sourceInstance) {\n    var source = getSourceForInstance(sourceInstance);\n    return (onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function');\n}\n\nvar IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\nvar ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\nvar FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n\nvar EffectsRunner = /** @class */ (function () {\n    function EffectsRunner(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    EffectsRunner.prototype.start = function () {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    };\n    EffectsRunner.prototype.ngOnDestroy = function () {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    };\n    EffectsRunner = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [EffectSources,\n            Store])\n    ], EffectsRunner);\n    return EffectsRunner;\n}());\n\nvar ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nvar EffectsRootModule = /** @class */ (function () {\n    function EffectsRootModule(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach(function (effectSourceInstance) {\n            return sources.addEffects(effectSourceInstance);\n        });\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    EffectsRootModule.prototype.addEffects = function (effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    };\n    EffectsRootModule = __decorate([\n        NgModule({}),\n        __param(3, Inject(ROOT_EFFECTS)),\n        __param(4, Optional()),\n        __param(5, Optional()),\n        __metadata(\"design:paramtypes\", [EffectSources,\n            EffectsRunner,\n            Store, Array, StoreRootModule,\n            StoreFeatureModule])\n    ], EffectsRootModule);\n    return EffectsRootModule;\n}());\n\nvar EffectsFeatureModule = /** @class */ (function () {\n    function EffectsFeatureModule(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        effectSourceGroups.forEach(function (group) {\n            return group.forEach(function (effectSourceInstance) {\n                return root.addEffects(effectSourceInstance);\n            });\n        });\n    }\n    EffectsFeatureModule = __decorate([\n        NgModule({}),\n        __param(1, Inject(FEATURE_EFFECTS)),\n        __param(2, Optional()),\n        __param(3, Optional()),\n        __metadata(\"design:paramtypes\", [EffectsRootModule, Array, StoreRootModule,\n            StoreFeatureModule])\n    ], EffectsFeatureModule);\n    return EffectsFeatureModule;\n}());\n\nvar EffectsModule = /** @class */ (function () {\n    function EffectsModule() {\n    }\n    EffectsModule.forFeature = function (featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    EffectsModule.forRoot = function (rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    EffectsModule = __decorate([\n        NgModule({})\n    ], EffectsModule);\n    return EffectsModule;\n}());\nfunction createSourceInstances() {\n    var instances = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        instances[_i] = arguments[_i];\n    }\n    return instances;\n}\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n    var _a = typeof configOrProject === 'function'\n        ? {\n            project: configOrProject,\n            error: errorFn,\n            operator: concatMap,\n            complete: undefined,\n            unsubscribe: undefined,\n        }\n        : __assign({}, configOrProject, { operator: configOrProject.operator || concatMap }), project = _a.project, error = _a.error, complete = _a.complete, operator = _a.operator, unsubscribe = _a.unsubscribe;\n    return function (source) {\n        return defer(function () {\n            var subject = new Subject();\n            return merge(source.pipe(operator(function (input, index) {\n                return defer(function () {\n                    var completed = false;\n                    var errored = false;\n                    var projectedCount = 0;\n                    return project(input, index).pipe(materialize(), map(function (notification) {\n                        switch (notification.kind) {\n                            case 'E':\n                                errored = true;\n                                return new Notification(\n                                // TODO: remove any in RxJS 6.5\n                                'N', error(notification.error, input));\n                            case 'C':\n                                completed = true;\n                                return complete\n                                    ? new Notification(\n                                    // TODO: remove any in RxJS 6.5\n                                    'N', complete(projectedCount, input))\n                                    : undefined;\n                            default:\n                                ++projectedCount;\n                                return notification;\n                        }\n                    }), filter(function (n) { return n != null; }), dematerialize(), finalize(function () {\n                        if (!completed && !errored && unsubscribe) {\n                            subject.next(unsubscribe(projectedCount, input));\n                        }\n                    }));\n                });\n            })), subject);\n        });\n    };\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { EffectsFeatureModule as ɵngrx_modules_effects_effects_c, createSourceInstances as ɵngrx_modules_effects_effects_a, EffectsRootModule as ɵngrx_modules_effects_effects_b, EffectsRunner as ɵngrx_modules_effects_effects_f, FEATURE_EFFECTS as ɵngrx_modules_effects_effects_e, ROOT_EFFECTS as ɵngrx_modules_effects_effects_d, createEffect, Effect, getEffectsMetadata, mergeEffects, Actions, ofType, EffectsModule, EffectSources, ROOT_EFFECTS_INIT, act };\n//# sourceMappingURL=effects.js.map\n","/**\n * @license NgRx 8.3.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { __assign, __extends, __decorate, __param, __metadata, __spread, __read } from 'tslib';\nimport { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, INITIAL_STATE, ReducerObservable, ScannedActionsSubject, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { empty, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n\nvar StoreDevtoolsConfig = /** @class */ (function () {\n    function StoreDevtoolsConfig() {\n    }\n    return StoreDevtoolsConfig;\n}());\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\nvar INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\nfunction noMonitor() {\n    return null;\n}\nvar DEFAULT_NAME = 'NgRx Store DevTools';\nfunction createConfig(_options) {\n    var DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n        actionSanitizer: undefined,\n        stateSanitizer: undefined,\n        name: DEFAULT_NAME,\n        serialize: false,\n        logOnly: false,\n        // Add all features explicitely. This prevent buggy behavior for\n        // options like \"lock\" which might otherwise not show up.\n        features: {\n            pause: true,\n            lock: true,\n            persist: true,\n            export: true,\n            import: 'custom',\n            jump: true,\n            skip: true,\n            reorder: true,\n            dispatch: true,\n            test: true,\n        },\n    };\n    var options = typeof _options === 'function' ? _options() : _options;\n    var logOnly = options.logOnly\n        ? { pause: true, export: true, test: true }\n        : false;\n    var features = options.features || logOnly || DEFAULT_OPTIONS.features;\n    var config = Object.assign({}, DEFAULT_OPTIONS, { features: features }, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(\"Devtools 'maxAge' cannot be less than 2, got \" + config.maxAge);\n    }\n    return config;\n}\n\nvar PERFORM_ACTION = 'PERFORM_ACTION';\nvar REFRESH = 'REFRESH';\nvar RESET = 'RESET';\nvar ROLLBACK = 'ROLLBACK';\nvar COMMIT = 'COMMIT';\nvar SWEEP = 'SWEEP';\nvar TOGGLE_ACTION = 'TOGGLE_ACTION';\nvar SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nvar JUMP_TO_STATE = 'JUMP_TO_STATE';\nvar JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nvar IMPORT_STATE = 'IMPORT_STATE';\nvar LOCK_CHANGES = 'LOCK_CHANGES';\nvar PAUSE_RECORDING = 'PAUSE_RECORDING';\nvar PerformAction = /** @class */ (function () {\n    function PerformAction(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n    return PerformAction;\n}());\nvar Refresh = /** @class */ (function () {\n    function Refresh() {\n        this.type = REFRESH;\n    }\n    return Refresh;\n}());\nvar Reset = /** @class */ (function () {\n    function Reset(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n    return Reset;\n}());\nvar Rollback = /** @class */ (function () {\n    function Rollback(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n    return Rollback;\n}());\nvar Commit = /** @class */ (function () {\n    function Commit(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n    return Commit;\n}());\nvar Sweep = /** @class */ (function () {\n    function Sweep() {\n        this.type = SWEEP;\n    }\n    return Sweep;\n}());\nvar ToggleAction = /** @class */ (function () {\n    function ToggleAction(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n    return ToggleAction;\n}());\nvar JumpToState = /** @class */ (function () {\n    function JumpToState(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n    return JumpToState;\n}());\nvar JumpToAction = /** @class */ (function () {\n    function JumpToAction(actionId) {\n        this.actionId = actionId;\n        this.type = JUMP_TO_ACTION;\n    }\n    return JumpToAction;\n}());\nvar ImportState = /** @class */ (function () {\n    function ImportState(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n    return ImportState;\n}());\nvar LockChanges = /** @class */ (function () {\n    function LockChanges(status) {\n        this.status = status;\n        this.type = LOCK_CHANGES;\n    }\n    return LockChanges;\n}());\nvar PauseRecording = /** @class */ (function () {\n    function PauseRecording(status) {\n        this.status = status;\n        this.type = PAUSE_RECORDING;\n    }\n    return PauseRecording;\n}());\n\nfunction difference(first, second) {\n    return first.filter(function (item) { return second.indexOf(item) < 0; });\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n    var computedStates = liftedState.computedStates, currentStateIndex = liftedState.currentStateIndex;\n    // At start up NgRx dispatches init actions,\n    // When these init actions are being filtered out by the predicate or safe/block list options\n    // we don't have a complete computed states yet.\n    // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n    if (currentStateIndex >= computedStates.length) {\n        var state_1 = computedStates[computedStates.length - 1].state;\n        return state_1;\n    }\n    var state = computedStates[currentStateIndex].state;\n    return state;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action) {\n    return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n    return Object.keys(actions).reduce(function (sanitizedActions, actionIdx) {\n        var idx = Number(actionIdx);\n        sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n        return sanitizedActions;\n    }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n    return __assign({}, action, { action: actionSanitizer(action.action, actionIdx) });\n}\n/**\n * Sanitizes given states with given function.\n */\nfunction sanitizeStates(stateSanitizer, states) {\n    return states.map(function (computedState, idx) { return ({\n        state: sanitizeState(stateSanitizer, computedState.state, idx),\n        error: computedState.error,\n    }); });\n}\n/**\n * Sanitizes given state with given function.\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n    return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\nfunction shouldFilterActions(config) {\n    return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n    var filteredStagedActionIds = [];\n    var filteredActionsById = {};\n    var filteredComputedStates = [];\n    liftedState.stagedActionIds.forEach(function (id, idx) {\n        var liftedAction = liftedState.actionsById[id];\n        if (!liftedAction)\n            return;\n        if (idx &&\n            isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n            return;\n        }\n        filteredActionsById[id] = liftedAction;\n        filteredStagedActionIds.push(id);\n        filteredComputedStates.push(liftedState.computedStates[idx]);\n    });\n    return __assign({}, liftedState, { stagedActionIds: filteredStagedActionIds, actionsById: filteredActionsById, computedStates: filteredComputedStates });\n}\n/**\n * Return true is the action should be ignored\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n    var predicateMatch = predicate && !predicate(state, action.action);\n    var safelistMatch = safelist && !action.action.type.match(safelist.join('|'));\n    var blocklistMatch = blockedlist && action.action.type.match(blockedlist.join('|'));\n    return predicateMatch || safelistMatch || blocklistMatch;\n}\n\nvar DevtoolsDispatcher = /** @class */ (function (_super) {\n    __extends(DevtoolsDispatcher, _super);\n    function DevtoolsDispatcher() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DevtoolsDispatcher = __decorate([\n        Injectable()\n    ], DevtoolsDispatcher);\n    return DevtoolsDispatcher;\n}(ActionsSubject));\n\nvar ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\nvar DevtoolsExtension = /** @class */ (function () {\n    function DevtoolsExtension(devtoolsExtension, config, dispatcher) {\n        this.config = config;\n        this.dispatcher = dispatcher;\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    DevtoolsExtension.prototype.notify = function (action, state) {\n        var _this = this;\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        // Check to see if the action requires a full update of the liftedState.\n        // If it is a simple action generated by the user's app and the recording\n        // is not locked/paused, only send the action and the current state (fast).\n        //\n        // A full liftedState update (slow: serializes the entire liftedState) is\n        // only required when:\n        //   a) redux-devtools-extension fires the @@Init action (ignored by\n        //      @ngrx/store-devtools)\n        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n        //      or @ngrx/store/update-reducers)\n        //   c) the state has been recomputed due to time-traveling\n        //   d) any action that is not a PerformAction to err on the side of\n        //      caution.\n        if (action.type === PERFORM_ACTION) {\n            if (state.isLocked || state.isPaused) {\n                return;\n            }\n            var currentState = unliftState(state);\n            if (shouldFilterActions(this.config) &&\n                isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n                return;\n            }\n            var sanitizedState_1 = this.config.stateSanitizer\n                ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex)\n                : currentState;\n            var sanitizedAction_1 = this.config.actionSanitizer\n                ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId)\n                : action;\n            this.sendToReduxDevtools(function () {\n                return _this.extensionConnection.send(sanitizedAction_1, sanitizedState_1);\n            });\n        }\n        else {\n            // Requires full state update\n            var sanitizedLiftedState_1 = __assign({}, state, { stagedActionIds: state.stagedActionIds, actionsById: this.config.actionSanitizer\n                    ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n                    : state.actionsById, computedStates: this.config.stateSanitizer\n                    ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n                    : state.computedStates });\n            this.sendToReduxDevtools(function () {\n                return _this.devtoolsExtension.send(null, sanitizedLiftedState_1, _this.getExtensionConfig(_this.config));\n            });\n        }\n    };\n    DevtoolsExtension.prototype.createChangesObservable = function () {\n        var _this = this;\n        if (!this.devtoolsExtension) {\n            return empty();\n        }\n        return new Observable(function (subscriber) {\n            var connection = _this.devtoolsExtension.connect(_this.getExtensionConfig(_this.config));\n            _this.extensionConnection = connection;\n            connection.init();\n            connection.subscribe(function (change) { return subscriber.next(change); });\n            return connection.unsubscribe;\n        });\n    };\n    DevtoolsExtension.prototype.createActionStreams = function () {\n        var _this = this;\n        // Listens to all changes\n        var changes$ = this.createChangesObservable().pipe(share());\n        // Listen for the start action\n        var start$ = changes$.pipe(filter(function (change) { return change.type === ExtensionActionTypes.START; }));\n        // Listen for the stop action\n        var stop$ = changes$.pipe(filter(function (change) { return change.type === ExtensionActionTypes.STOP; }));\n        // Listen for lifted actions\n        var liftedActions$ = changes$.pipe(filter(function (change) { return change.type === ExtensionActionTypes.DISPATCH; }), map(function (change) { return _this.unwrapAction(change.payload); }), concatMap(function (action) {\n            if (action.type === IMPORT_STATE) {\n                // State imports may happen in two situations:\n                // 1. Explicitly by user\n                // 2. User activated the \"persist state accross reloads\" option\n                //    and now the state is imported during reload.\n                // Because of option 2, we need to give possible\n                // lazy loaded reducers time to instantiate.\n                // As soon as there is no UPDATE action within 1 second,\n                // it is assumed that all reducers are loaded.\n                return _this.dispatcher.pipe(filter(function (action) { return action.type === UPDATE; }), timeout(1000), debounceTime(1000), map(function () { return action; }), catchError(function () { return of(action); }), take(1));\n            }\n            else {\n                return of(action);\n            }\n        }));\n        // Listen for unlifted actions\n        var actions$ = changes$.pipe(filter(function (change) { return change.type === ExtensionActionTypes.ACTION; }), map(function (change) { return _this.unwrapAction(change.payload); }));\n        var actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n        var liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n        this.start$ = start$.pipe(takeUntil(stop$));\n        // Only take the action sources between the start/stop events\n        this.actions$ = this.start$.pipe(switchMap(function () { return actionsUntilStop$; }));\n        this.liftedActions$ = this.start$.pipe(switchMap(function () { return liftedUntilStop$; }));\n    };\n    DevtoolsExtension.prototype.unwrapAction = function (action) {\n        return typeof action === 'string' ? eval(\"(\" + action + \")\") : action;\n    };\n    DevtoolsExtension.prototype.getExtensionConfig = function (config) {\n        var extensionOptions = {\n            name: config.name,\n            features: config.features,\n            serialize: config.serialize,\n        };\n        if (config.maxAge !== false /* support === 0 */) {\n            extensionOptions.maxAge = config.maxAge;\n        }\n        return extensionOptions;\n    };\n    DevtoolsExtension.prototype.sendToReduxDevtools = function (send) {\n        try {\n            send();\n        }\n        catch (err) {\n            console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n        }\n    };\n    DevtoolsExtension = __decorate([\n        Injectable(),\n        __param(0, Inject(REDUX_DEVTOOLS_EXTENSION)),\n        __param(1, Inject(STORE_DEVTOOLS_CONFIG)),\n        __metadata(\"design:paramtypes\", [Object, StoreDevtoolsConfig,\n            DevtoolsDispatcher])\n    ], DevtoolsExtension);\n    return DevtoolsExtension;\n}());\n\nvar INIT_ACTION = { type: INIT };\nvar RECOMPUTE = '@ngrx/store-devtools/recompute';\nvar RECOMPUTE_ACTION = { type: RECOMPUTE };\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n    if (error) {\n        return {\n            state: state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    var nextState = state;\n    var nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        errorHandler.handleError(err.stack || err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    // If the recording is paused, recompute all states up until the pause state,\n    // else recompute all states.\n    var lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n    for (var i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n        var actionId = stagedActionIds[i];\n        var action = actionsById[actionId].action;\n        var previousEntry = nextComputedStates[i - 1];\n        var previousState = previousEntry ? previousEntry.state : committedState;\n        var previousError = previousEntry ? previousEntry.error : undefined;\n        var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        var entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n        nextComputedStates.push(entry);\n    }\n    // If the recording is paused, the last state will not be recomputed,\n    // because it's essentially not part of the state history.\n    if (isPaused) {\n        nextComputedStates.push(computedStates[computedStates.length - 1]);\n    }\n    return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n        isLocked: false,\n        isPaused: false,\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options) {\n    if (options === void 0) { options = {}; }\n    /**\n     * Manages how the history actions modify the history state.\n     */\n    return function (reducer) { return function (liftedState, liftedAction) {\n        var _a;\n        var _b = liftedState || initialLiftedState, monitorState = _b.monitorState, actionsById = _b.actionsById, nextActionId = _b.nextActionId, stagedActionIds = _b.stagedActionIds, skippedActionIds = _b.skippedActionIds, committedState = _b.committedState, currentStateIndex = _b.currentStateIndex, computedStates = _b.computedStates, isLocked = _b.isLocked, isPaused = _b.isPaused;\n        if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n        }\n        function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n            var excess = n;\n            var idsToDelete = stagedActionIds.slice(1, excess + 1);\n            for (var i = 0; i < idsToDelete.length; i++) {\n                if (computedStates[i + 1].error) {\n                    // Stop if error is found. Commit actions up to error.\n                    excess = i;\n                    idsToDelete = stagedActionIds.slice(1, excess + 1);\n                    break;\n                }\n                else {\n                    delete actionsById[idsToDelete[i]];\n                }\n            }\n            skippedActionIds = skippedActionIds.filter(function (id) { return idsToDelete.indexOf(id) === -1; });\n            stagedActionIds = __spread([0], stagedActionIds.slice(excess + 1));\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex =\n                currentStateIndex > excess ? currentStateIndex - excess : 0;\n        }\n        function commitChanges() {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n        }\n        // By default, aggressively recompute every state whatever happens.\n        // This has O(n) performance, so we'll override this to a sensible\n        // value whenever we feel like we don't have to recompute the states.\n        var minInvalidatedStateIndex = 0;\n        switch (liftedAction.type) {\n            case LOCK_CHANGES: {\n                isLocked = liftedAction.status;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case PAUSE_RECORDING: {\n                isPaused = liftedAction.status;\n                if (isPaused) {\n                    // Add a pause action to signal the devtools-user the recording is paused.\n                    // The corresponding state will be overwritten on each update to always contain\n                    // the latest state (see Actions.PERFORM_ACTION).\n                    stagedActionIds = __spread(stagedActionIds, [nextActionId]);\n                    actionsById[nextActionId] = new PerformAction({\n                        type: '@ngrx/devtools/pause',\n                    }, +Date.now());\n                    nextActionId++;\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n                    if (currentStateIndex === stagedActionIds.length - 2) {\n                        currentStateIndex++;\n                    }\n                    minInvalidatedStateIndex = Infinity;\n                }\n                else {\n                    commitChanges();\n                }\n                break;\n            }\n            case RESET: {\n                // Get back to the state the store was created with.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case COMMIT: {\n                commitChanges();\n                break;\n            }\n            case ROLLBACK: {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case TOGGLE_ACTION: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                var actionId_1 = liftedAction.id;\n                var index = skippedActionIds.indexOf(actionId_1);\n                if (index === -1) {\n                    skippedActionIds = __spread([actionId_1], skippedActionIds);\n                }\n                else {\n                    skippedActionIds = skippedActionIds.filter(function (id) { return id !== actionId_1; });\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId_1);\n                break;\n            }\n            case SET_ACTIONS_ACTIVE: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                var start = liftedAction.start, end = liftedAction.end, active = liftedAction.active;\n                var actionIds = [];\n                for (var i = start; i < end; i++)\n                    actionIds.push(i);\n                if (active) {\n                    skippedActionIds = difference(skippedActionIds, actionIds);\n                }\n                else {\n                    skippedActionIds = __spread(skippedActionIds, actionIds);\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n            }\n            case JUMP_TO_STATE: {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index;\n                // Optimization: we know the history has not changed.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case JUMP_TO_ACTION: {\n                // Jumps to a corresponding state to a specific action.\n                // Useful when filtering actions.\n                var index = stagedActionIds.indexOf(liftedAction.actionId);\n                if (index !== -1)\n                    currentStateIndex = index;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case SWEEP: {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n            }\n            case PERFORM_ACTION: {\n                // Ignore action and return state as is if recording is locked\n                if (isLocked) {\n                    return liftedState || initialLiftedState;\n                }\n                if (isPaused ||\n                    (liftedState &&\n                        isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist))) {\n                    // If recording is paused or if the action should be ignored, overwrite the last state\n                    // (corresponds to the pause action) and keep everything else as is.\n                    // This way, the app gets the new current state while the devtools\n                    // do not record another action.\n                    var lastState = computedStates[computedStates.length - 1];\n                    computedStates = __spread(computedStates.slice(0, -1), [\n                        computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler),\n                    ]);\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n                // Auto-commit as new actions come in.\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                    commitExcessActions(1);\n                }\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                    currentStateIndex++;\n                }\n                var actionId = nextActionId++;\n                // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n                actionsById[actionId] = liftedAction;\n                stagedActionIds = __spread(stagedActionIds, [actionId]);\n                // Optimization: we know that only the new action needs computing.\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n            }\n            case IMPORT_STATE: {\n                // Completely replace everything.\n                (_a = liftedAction.nextLiftedState, monitorState = _a.monitorState, actionsById = _a.actionsById, nextActionId = _a.nextActionId, stagedActionIds = _a.stagedActionIds, skippedActionIds = _a.skippedActionIds, committedState = _a.committedState, currentStateIndex = _a.currentStateIndex, computedStates = _a.computedStates, isLocked = _a.isLocked, \n                // prettier-ignore\n                isPaused = _a.isPaused);\n                break;\n            }\n            case INIT: {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            case UPDATE: {\n                var stateHasErrors = computedStates.filter(function (state) { return state.error; }).length > 0;\n                if (stateHasErrors) {\n                    // Recompute all states\n                    minInvalidatedStateIndex = 0;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        // States must be recomputed before committing excess.\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                        // Avoid double computation.\n                        minInvalidatedStateIndex = Infinity;\n                    }\n                }\n                else {\n                    // If not paused/locked, add a new action to signal devtools-user\n                    // that there was a reducer update.\n                    if (!isPaused && !isLocked) {\n                        if (currentStateIndex === stagedActionIds.length - 1) {\n                            currentStateIndex++;\n                        }\n                        // Add a new action to only recompute state\n                        var actionId = nextActionId++;\n                        actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                        stagedActionIds = __spread(stagedActionIds, [actionId]);\n                        minInvalidatedStateIndex = stagedActionIds.length - 1;\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    }\n                    // Recompute state history with latest reducer and update action\n                    computedStates = computedStates.map(function (cmp) { return (__assign({}, cmp, { state: reducer(cmp.state, RECOMPUTE_ACTION) })); });\n                    currentStateIndex = stagedActionIds.length - 1;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                    }\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            default: {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n        }\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n        monitorState = monitorReducer(monitorState, liftedAction);\n        return {\n            monitorState: monitorState,\n            actionsById: actionsById,\n            nextActionId: nextActionId,\n            stagedActionIds: stagedActionIds,\n            skippedActionIds: skippedActionIds,\n            committedState: committedState,\n            currentStateIndex: currentStateIndex,\n            computedStates: computedStates,\n            isLocked: isLocked,\n            isPaused: isPaused,\n        };\n    }; };\n}\n\nvar StoreDevtools = /** @class */ (function () {\n    function StoreDevtools(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n        var _this = this;\n        var liftedInitialState = liftInitialState(initialState, config.monitor);\n        var liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n        var liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n        var liftedReducer$ = reducers$.pipe(map(liftReducer));\n        var liftedStateSubject = new ReplaySubject(1);\n        var liftedStateSubscription = liftedAction$\n            .pipe(withLatestFrom(liftedReducer$), scan(function (_a, _b) {\n            var liftedState = _a.state;\n            var _c = __read(_b, 2), action = _c[0], reducer = _c[1];\n            var reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completly our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n                reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action: action };\n        }, { state: liftedInitialState, action: null }))\n            .subscribe(function (_a) {\n            var state = _a.state, action = _a.action;\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                var unliftedAction = action.action;\n                scannedActions.next(unliftedAction);\n            }\n        });\n        var extensionStartSubscription = extension.start$.subscribe(function () {\n            _this.refresh();\n        });\n        var liftedState$ = liftedStateSubject.asObservable();\n        var state$ = liftedState$.pipe(map(unliftState));\n        this.extensionStartSubscription = extensionStartSubscription;\n        this.stateSubscription = liftedStateSubscription;\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    StoreDevtools.prototype.dispatch = function (action) {\n        this.dispatcher.next(action);\n    };\n    StoreDevtools.prototype.next = function (action) {\n        this.dispatcher.next(action);\n    };\n    StoreDevtools.prototype.error = function (error) { };\n    StoreDevtools.prototype.complete = function () { };\n    StoreDevtools.prototype.performAction = function (action) {\n        this.dispatch(new PerformAction(action, +Date.now()));\n    };\n    StoreDevtools.prototype.refresh = function () {\n        this.dispatch(new Refresh());\n    };\n    StoreDevtools.prototype.reset = function () {\n        this.dispatch(new Reset(+Date.now()));\n    };\n    StoreDevtools.prototype.rollback = function () {\n        this.dispatch(new Rollback(+Date.now()));\n    };\n    StoreDevtools.prototype.commit = function () {\n        this.dispatch(new Commit(+Date.now()));\n    };\n    StoreDevtools.prototype.sweep = function () {\n        this.dispatch(new Sweep());\n    };\n    StoreDevtools.prototype.toggleAction = function (id) {\n        this.dispatch(new ToggleAction(id));\n    };\n    StoreDevtools.prototype.jumpToAction = function (actionId) {\n        this.dispatch(new JumpToAction(actionId));\n    };\n    StoreDevtools.prototype.jumpToState = function (index) {\n        this.dispatch(new JumpToState(index));\n    };\n    StoreDevtools.prototype.importState = function (nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    };\n    StoreDevtools.prototype.lockChanges = function (status) {\n        this.dispatch(new LockChanges(status));\n    };\n    StoreDevtools.prototype.pauseRecording = function (status) {\n        this.dispatch(new PauseRecording(status));\n    };\n    StoreDevtools = __decorate([\n        Injectable(),\n        __param(6, Inject(INITIAL_STATE)),\n        __param(7, Inject(STORE_DEVTOOLS_CONFIG)),\n        __metadata(\"design:paramtypes\", [DevtoolsDispatcher,\n            ActionsSubject,\n            ReducerObservable,\n            DevtoolsExtension,\n            ScannedActionsSubject,\n            ErrorHandler, Object, StoreDevtoolsConfig])\n    ], StoreDevtools);\n    return StoreDevtools;\n}());\n\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n    var extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof window[extensionKey] !== 'undefined') {\n        return window[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\nvar StoreDevtoolsModule = /** @class */ (function () {\n    function StoreDevtoolsModule() {\n    }\n    StoreDevtoolsModule_1 = StoreDevtoolsModule;\n    StoreDevtoolsModule.instrument = function (options) {\n        if (options === void 0) { options = {}; }\n        return {\n            ngModule: StoreDevtoolsModule_1,\n            providers: [\n                DevtoolsExtension,\n                DevtoolsDispatcher,\n                StoreDevtools,\n                {\n                    provide: INITIAL_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n                    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n                    useFactory: createIsExtensionOrMonitorPresent,\n                },\n                {\n                    provide: REDUX_DEVTOOLS_EXTENSION,\n                    useFactory: createReduxDevtoolsExtension,\n                },\n                {\n                    provide: STORE_DEVTOOLS_CONFIG,\n                    deps: [INITIAL_OPTIONS],\n                    useFactory: createConfig,\n                },\n                {\n                    provide: StateObservable,\n                    deps: [StoreDevtools],\n                    useFactory: createStateObservable,\n                },\n                {\n                    provide: ReducerManagerDispatcher,\n                    useExisting: DevtoolsDispatcher,\n                },\n            ],\n        };\n    };\n    var StoreDevtoolsModule_1;\n    StoreDevtoolsModule = StoreDevtoolsModule_1 = __decorate([\n        NgModule({})\n    ], StoreDevtoolsModule);\n    return StoreDevtoolsModule;\n}());\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS as ɵngrx_modules_store_devtools_store_devtools_f, STORE_DEVTOOLS_CONFIG as ɵngrx_modules_store_devtools_store_devtools_e, createConfig as ɵngrx_modules_store_devtools_store_devtools_h, noMonitor as ɵngrx_modules_store_devtools_store_devtools_g, DevtoolsDispatcher as ɵngrx_modules_store_devtools_store_devtools_k, DevtoolsExtension as ɵngrx_modules_store_devtools_store_devtools_j, REDUX_DEVTOOLS_EXTENSION as ɵngrx_modules_store_devtools_store_devtools_i, IS_EXTENSION_OR_MONITOR_PRESENT as ɵngrx_modules_store_devtools_store_devtools_a, createIsExtensionOrMonitorPresent as ɵngrx_modules_store_devtools_store_devtools_b, createReduxDevtoolsExtension as ɵngrx_modules_store_devtools_store_devtools_c, createStateObservable as ɵngrx_modules_store_devtools_store_devtools_d, StoreDevtoolsModule, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig };\n//# sourceMappingURL=store-devtools.js.map\n","/**\n * @license NgRx 8.3.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { __assign, __spread, __extends, __decorate, __metadata, __param, __read, __values } from 'tslib';\nimport { Injectable, InjectionToken, Inject, isDevMode, NgModule, Injector } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\nfunction createAction(type, config) {\n    if (typeof config === 'function') {\n        return defineType(type, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return (__assign({}, config.apply(void 0, __spread(args)), { type: type }));\n        });\n    }\n    var as = config ? config._as : 'empty';\n    switch (as) {\n        case 'empty':\n            return defineType(type, function () { return ({ type: type }); });\n        case 'props':\n            return defineType(type, function (props) { return (__assign({}, props, { type: type })); });\n        default:\n            throw new Error('Unexpected config.');\n    }\n}\nfunction props() {\n    // the return type does not match TypePropertyIsNotAllowed, so double casting\n    // is used.\n    return { _as: 'props', _p: undefined };\n}\nfunction union(creators) {\n    return undefined;\n}\nfunction defineType(type, creator) {\n    return Object.defineProperty(creator, 'type', {\n        value: type,\n        writable: false,\n    });\n}\n\nvar INIT = '@ngrx/store/init';\nvar ActionsSubject = /** @class */ (function (_super) {\n    __extends(ActionsSubject, _super);\n    function ActionsSubject() {\n        return _super.call(this, { type: INIT }) || this;\n    }\n    ActionsSubject.prototype.next = function (action) {\n        if (typeof action === 'function') {\n            throw new TypeError(\"\\n        Dispatch expected an object, instead it received a function.\\n        If you're using the createAction function, make sure to invoke the function\\n        before dispatching the action. For example, someAction should be someAction().\");\n        }\n        else if (typeof action === 'undefined') {\n            throw new TypeError(\"Actions must be objects\");\n        }\n        else if (typeof action.type === 'undefined') {\n            throw new TypeError(\"Actions must have a type property\");\n        }\n        _super.prototype.next.call(this, action);\n    };\n    ActionsSubject.prototype.complete = function () {\n        /* noop */\n    };\n    ActionsSubject.prototype.ngOnDestroy = function () {\n        _super.prototype.complete.call(this);\n    };\n    ActionsSubject = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [])\n    ], ActionsSubject);\n    return ActionsSubject;\n}(BehaviorSubject));\nvar ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\n\nvar _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\nvar INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nvar REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\nvar _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\nvar INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\nvar _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\nvar STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nvar _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\nvar _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\nvar _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\nvar _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\nvar _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\nvar FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n */\nvar USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\n * Meta reducers defined either internally by @ngrx/store or by library authors\n */\nvar META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n */\nvar _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n */\nvar USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\n * Runtime checks defined by the user via forRoot()\n */\nvar _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\n * Runtime checks currently in use\n */\nvar _ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\n\nfunction combineReducers(reducers, initialState) {\n    if (initialState === void 0) { initialState = {}; }\n    var reducerKeys = Object.keys(reducers);\n    var finalReducers = {};\n    for (var i = 0; i < reducerKeys.length; i++) {\n        var key = reducerKeys[i];\n        if (typeof reducers[key] === 'function') {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    var finalReducerKeys = Object.keys(finalReducers);\n    return function combination(state, action) {\n        state = state === undefined ? initialState : state;\n        var hasChanged = false;\n        var nextState = {};\n        for (var i = 0; i < finalReducerKeys.length; i++) {\n            var key = finalReducerKeys[i];\n            var reducer = finalReducers[key];\n            var previousStateForKey = state[key];\n            var nextStateForKey = reducer(previousStateForKey, action);\n            nextState[key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        return hasChanged ? nextState : state;\n    };\n}\nfunction omit(object, keyToRemove) {\n    return Object.keys(object)\n        .filter(function (key) { return key !== keyToRemove; })\n        .reduce(function (result, key) {\n        var _a;\n        return Object.assign(result, (_a = {}, _a[key] = object[key], _a));\n    }, {});\n}\nfunction compose() {\n    var functions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        functions[_i] = arguments[_i];\n    }\n    return function (arg) {\n        if (functions.length === 0) {\n            return arg;\n        }\n        var last = functions[functions.length - 1];\n        var rest = functions.slice(0, -1);\n        return rest.reduceRight(function (composed, fn) { return fn(composed); }, last(arg));\n    };\n}\nfunction createReducerFactory(reducerFactory, metaReducers) {\n    if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n        reducerFactory = compose.apply(null, __spread(metaReducers, [\n            reducerFactory,\n        ]));\n    }\n    return function (reducers, initialState) {\n        var reducer = reducerFactory(reducers);\n        return function (state, action) {\n            state = state === undefined ? initialState : state;\n            return reducer(state, action);\n        };\n    };\n}\nfunction createFeatureReducerFactory(metaReducers) {\n    var reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0\n        ? compose.apply(void 0, __spread(metaReducers)) : function (r) { return r; };\n    return function (reducer, initialState) {\n        reducer = reducerFactory(reducer);\n        return function (state, action) {\n            state = state === undefined ? initialState : state;\n            return reducer(state, action);\n        };\n    };\n}\n\nvar ReducerObservable = /** @class */ (function (_super) {\n    __extends(ReducerObservable, _super);\n    function ReducerObservable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ReducerObservable;\n}(Observable));\nvar ReducerManagerDispatcher = /** @class */ (function (_super) {\n    __extends(ReducerManagerDispatcher, _super);\n    function ReducerManagerDispatcher() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ReducerManagerDispatcher;\n}(ActionsSubject));\nvar UPDATE = '@ngrx/store/update-reducers';\nvar ReducerManager = /** @class */ (function (_super) {\n    __extends(ReducerManager, _super);\n    function ReducerManager(dispatcher, initialState, reducers, reducerFactory) {\n        var _this = _super.call(this, reducerFactory(reducers, initialState)) || this;\n        _this.dispatcher = dispatcher;\n        _this.initialState = initialState;\n        _this.reducers = reducers;\n        _this.reducerFactory = reducerFactory;\n        return _this;\n    }\n    ReducerManager.prototype.addFeature = function (feature) {\n        this.addFeatures([feature]);\n    };\n    ReducerManager.prototype.addFeatures = function (features) {\n        var reducers = features.reduce(function (reducerDict, _a) {\n            var reducers = _a.reducers, reducerFactory = _a.reducerFactory, metaReducers = _a.metaReducers, initialState = _a.initialState, key = _a.key;\n            var reducer = typeof reducers === 'function'\n                ? createFeatureReducerFactory(metaReducers)(reducers, initialState)\n                : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n            reducerDict[key] = reducer;\n            return reducerDict;\n        }, {});\n        this.addReducers(reducers);\n    };\n    ReducerManager.prototype.removeFeature = function (feature) {\n        this.removeFeatures([feature]);\n    };\n    ReducerManager.prototype.removeFeatures = function (features) {\n        this.removeReducers(features.map(function (p) { return p.key; }));\n    };\n    ReducerManager.prototype.addReducer = function (key, reducer) {\n        var _a;\n        this.addReducers((_a = {}, _a[key] = reducer, _a));\n    };\n    ReducerManager.prototype.addReducers = function (reducers) {\n        this.reducers = __assign({}, this.reducers, reducers);\n        this.updateReducers(Object.keys(reducers));\n    };\n    ReducerManager.prototype.removeReducer = function (featureKey) {\n        this.removeReducers([featureKey]);\n    };\n    ReducerManager.prototype.removeReducers = function (featureKeys) {\n        var _this = this;\n        featureKeys.forEach(function (key) {\n            _this.reducers = omit(_this.reducers, key) /*TODO(#823)*/;\n        });\n        this.updateReducers(featureKeys);\n    };\n    ReducerManager.prototype.updateReducers = function (featureKeys) {\n        this.next(this.reducerFactory(this.reducers, this.initialState));\n        this.dispatcher.next({\n            type: UPDATE,\n            features: featureKeys,\n        });\n    };\n    ReducerManager.prototype.ngOnDestroy = function () {\n        this.complete();\n    };\n    ReducerManager = __decorate([\n        Injectable(),\n        __param(1, Inject(INITIAL_STATE)),\n        __param(2, Inject(INITIAL_REDUCERS)),\n        __param(3, Inject(REDUCER_FACTORY)),\n        __metadata(\"design:paramtypes\", [ReducerManagerDispatcher, Object, Object, Function])\n    ], ReducerManager);\n    return ReducerManager;\n}(BehaviorSubject));\nvar REDUCER_MANAGER_PROVIDERS = [\n    ReducerManager,\n    { provide: ReducerObservable, useExisting: ReducerManager },\n    { provide: ReducerManagerDispatcher, useExisting: ActionsSubject },\n];\n\nvar ScannedActionsSubject = /** @class */ (function (_super) {\n    __extends(ScannedActionsSubject, _super);\n    function ScannedActionsSubject() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ScannedActionsSubject.prototype.ngOnDestroy = function () {\n        this.complete();\n    };\n    ScannedActionsSubject = __decorate([\n        Injectable()\n    ], ScannedActionsSubject);\n    return ScannedActionsSubject;\n}(Subject));\nvar SCANNED_ACTIONS_SUBJECT_PROVIDERS = [\n    ScannedActionsSubject,\n];\n\nvar StateObservable = /** @class */ (function (_super) {\n    __extends(StateObservable, _super);\n    function StateObservable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StateObservable;\n}(Observable));\nvar State = /** @class */ (function (_super) {\n    __extends(State, _super);\n    function State(actions$, reducer$, scannedActions, initialState) {\n        var _this = _super.call(this, initialState) || this;\n        var actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n        var withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n        var seed = { state: initialState };\n        var stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n        _this.stateSubscription = stateAndAction$.subscribe(function (_a) {\n            var state = _a.state, action = _a.action;\n            _this.next(state);\n            scannedActions.next(action);\n        });\n        return _this;\n    }\n    State.prototype.ngOnDestroy = function () {\n        this.stateSubscription.unsubscribe();\n        this.complete();\n    };\n    State.INIT = INIT;\n    State = __decorate([\n        Injectable(),\n        __param(3, Inject(INITIAL_STATE)),\n        __metadata(\"design:paramtypes\", [ActionsSubject,\n            ReducerObservable,\n            ScannedActionsSubject, Object])\n    ], State);\n    return State;\n}(BehaviorSubject));\nfunction reduceState(stateActionPair, _a) {\n    if (stateActionPair === void 0) { stateActionPair = { state: undefined }; }\n    var _b = __read(_a, 2), action = _b[0], reducer = _b[1];\n    var state = stateActionPair.state;\n    return { state: reducer(state, action), action: action };\n}\nvar STATE_PROVIDERS = [\n    State,\n    { provide: StateObservable, useExisting: State },\n];\n\nvar Store = /** @class */ (function (_super) {\n    __extends(Store, _super);\n    function Store(state$, actionsObserver, reducerManager) {\n        var _this = _super.call(this) || this;\n        _this.actionsObserver = actionsObserver;\n        _this.reducerManager = reducerManager;\n        _this.source = state$;\n        return _this;\n    }\n    Store_1 = Store;\n    Store.prototype.select = function (pathOrMapFn) {\n        var paths = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            paths[_i - 1] = arguments[_i];\n        }\n        return select.call.apply(select, __spread([null, pathOrMapFn], paths))(this);\n    };\n    Store.prototype.lift = function (operator) {\n        var store = new Store_1(this, this.actionsObserver, this.reducerManager);\n        store.operator = operator;\n        return store;\n    };\n    Store.prototype.dispatch = function (action) {\n        this.actionsObserver.next(action);\n    };\n    Store.prototype.next = function (action) {\n        this.actionsObserver.next(action);\n    };\n    Store.prototype.error = function (err) {\n        this.actionsObserver.error(err);\n    };\n    Store.prototype.complete = function () {\n        this.actionsObserver.complete();\n    };\n    Store.prototype.addReducer = function (key, reducer) {\n        this.reducerManager.addReducer(key, reducer);\n    };\n    Store.prototype.removeReducer = function (key) {\n        this.reducerManager.removeReducer(key);\n    };\n    var Store_1;\n    Store = Store_1 = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [StateObservable,\n            ActionsSubject,\n            ReducerManager])\n    ], Store);\n    return Store;\n}(Observable));\nvar STORE_PROVIDERS = [Store];\nfunction select(pathOrMapFn, propsOrPath) {\n    var paths = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        paths[_i - 2] = arguments[_i];\n    }\n    return function selectOperator(source$) {\n        var mapped$;\n        if (typeof pathOrMapFn === 'string') {\n            var pathSlices = __spread([propsOrPath], paths).filter(Boolean);\n            mapped$ = source$.pipe(pluck.apply(void 0, __spread([pathOrMapFn], pathSlices)));\n        }\n        else if (typeof pathOrMapFn === 'function') {\n            mapped$ = source$.pipe(map(function (source) { return pathOrMapFn(source, propsOrPath); }));\n        }\n        else {\n            throw new TypeError(\"Unexpected type '\" + typeof pathOrMapFn + \"' in select operator,\" +\n                \" expected 'string' or 'function'\");\n        }\n        return mapped$.pipe(distinctUntilChanged());\n    };\n}\n\nfunction isEqualCheck(a, b) {\n    return a === b;\n}\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n    for (var i = 0; i < args.length; i++) {\n        if (!comparator(args[i], lastArguments[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction resultMemoize(projectionFn, isResultEqual) {\n    return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\nfunction defaultMemoize(projectionFn, isArgumentsEqual, isResultEqual) {\n    if (isArgumentsEqual === void 0) { isArgumentsEqual = isEqualCheck; }\n    if (isResultEqual === void 0) { isResultEqual = isEqualCheck; }\n    var lastArguments = null;\n    // tslint:disable-next-line:no-any anything could be the result.\n    var lastResult = null;\n    var overrideResult;\n    function reset() {\n        lastArguments = null;\n        lastResult = null;\n    }\n    function setResult(result) {\n        if (result === void 0) { result = undefined; }\n        overrideResult = result;\n    }\n    // tslint:disable-next-line:no-any anything could be the result.\n    function memoized() {\n        if (overrideResult !== undefined) {\n            return overrideResult;\n        }\n        if (!lastArguments) {\n            lastResult = projectionFn.apply(null, arguments);\n            lastArguments = arguments;\n            return lastResult;\n        }\n        if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n            return lastResult;\n        }\n        lastArguments = arguments;\n        var newResult = projectionFn.apply(null, arguments);\n        if (isResultEqual(lastResult, newResult)) {\n            return lastResult;\n        }\n        lastResult = newResult;\n        return newResult;\n    }\n    return { memoized: memoized, reset: reset, setResult: setResult };\n}\nfunction createSelector() {\n    var input = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        input[_i] = arguments[_i];\n    }\n    return createSelectorFactory(defaultMemoize).apply(void 0, __spread(input));\n}\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n    if (props === undefined) {\n        var args_1 = selectors.map(function (fn) { return fn(state); });\n        return memoizedProjector.memoized.apply(null, args_1);\n    }\n    var args = selectors.map(function (fn) {\n        return fn(state, props);\n    });\n    return memoizedProjector.memoized.apply(null, __spread(args, [props]));\n}\nfunction createSelectorFactory(memoize, options) {\n    if (options === void 0) { options = {\n        stateFn: defaultStateFn,\n    }; }\n    return function () {\n        var input = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            input[_i] = arguments[_i];\n        }\n        var args = input;\n        if (Array.isArray(args[0])) {\n            var _a = __read(args), head = _a[0], tail = _a.slice(1);\n            args = __spread(head, tail);\n        }\n        var selectors = args.slice(0, args.length - 1);\n        var projector = args[args.length - 1];\n        var memoizedSelectors = selectors.filter(function (selector) {\n            return selector.release && typeof selector.release === 'function';\n        });\n        var memoizedProjector = memoize(function () {\n            var selectors = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                selectors[_i] = arguments[_i];\n            }\n            return projector.apply(null, selectors);\n        });\n        var memoizedState = defaultMemoize(function (state, props) {\n            return options.stateFn.apply(null, [\n                state,\n                selectors,\n                props,\n                memoizedProjector,\n            ]);\n        });\n        function release() {\n            memoizedState.reset();\n            memoizedProjector.reset();\n            memoizedSelectors.forEach(function (selector) { return selector.release(); });\n        }\n        return Object.assign(memoizedState.memoized, {\n            release: release,\n            projector: memoizedProjector.memoized,\n            setResult: memoizedState.setResult,\n        });\n    };\n}\nfunction createFeatureSelector(featureName) {\n    return createSelector(function (state) {\n        var featureState = state[featureName];\n        if (isDevMode() && featureState === undefined) {\n            console.warn(\"The feature name \\\"\" + featureName + \"\\\" does \" +\n                'not exist in the state, therefore createFeatureSelector ' +\n                'cannot access it.  Be sure it is imported in a loaded module ' +\n                (\"using StoreModule.forRoot('\" + featureName + \"', ...) or \") +\n                (\"StoreModule.forFeature('\" + featureName + \"', ...).  If the default \") +\n                'state is intended to be undefined, as is the case with router ' +\n                'state, this development-only warning message can be ignored.');\n        }\n        return featureState;\n    }, function (featureState) { return featureState; });\n}\n\nfunction isUndefined(target) {\n    return target === undefined;\n}\nfunction isNull(target) {\n    return target === null;\n}\nfunction isArray(target) {\n    return Array.isArray(target);\n}\nfunction isString(target) {\n    return typeof target === 'string';\n}\nfunction isBoolean(target) {\n    return typeof target === 'boolean';\n}\nfunction isNumber(target) {\n    return typeof target === 'number';\n}\nfunction isObjectLike(target) {\n    return typeof target === 'object' && target !== null;\n}\nfunction isObject(target) {\n    return isObjectLike(target) && !isArray(target);\n}\nfunction isPlainObject(target) {\n    if (!isObject(target)) {\n        return false;\n    }\n    var targetPrototype = Object.getPrototypeOf(target);\n    return targetPrototype === Object.prototype || targetPrototype === null;\n}\nfunction isFunction(target) {\n    return typeof target === 'function';\n}\nfunction hasOwnProperty(target, propertyName) {\n    return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n    return function (state, action) {\n        var act = checks.action ? freeze(action) : action;\n        var nextState = reducer(state, act);\n        return checks.state ? freeze(nextState) : nextState;\n    };\n}\nfunction freeze(target) {\n    Object.freeze(target);\n    var targetIsFunction = isFunction(target);\n    Object.getOwnPropertyNames(target).forEach(function (prop) {\n        if (hasOwnProperty(target, prop) &&\n            (targetIsFunction\n                ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'\n                : true)) {\n            var propValue = target[prop];\n            if ((isObjectLike(propValue) || isFunction(propValue)) &&\n                !Object.isFrozen(propValue)) {\n                freeze(propValue);\n            }\n        }\n    });\n    return target;\n}\n\nfunction serializationCheckMetaReducer(reducer, checks) {\n    return function (state, action) {\n        if (checks.action) {\n            var unserializableAction = getUnserializable(action);\n            throwIfUnserializable(unserializableAction, 'action');\n        }\n        var nextState = reducer(state, action);\n        if (checks.state) {\n            var unserializableState = getUnserializable(nextState);\n            throwIfUnserializable(unserializableState, 'state');\n        }\n        return nextState;\n    };\n}\nfunction getUnserializable(target, path) {\n    if (path === void 0) { path = []; }\n    // Guard against undefined and null, e.g. a reducer that returns undefined\n    if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n        return {\n            path: ['root'],\n            value: target,\n        };\n    }\n    var keys = Object.keys(target);\n    return keys.reduce(function (result, key) {\n        if (result) {\n            return result;\n        }\n        var value = target[key];\n        if (isUndefined(value) ||\n            isNull(value) ||\n            isNumber(value) ||\n            isBoolean(value) ||\n            isString(value) ||\n            isArray(value)) {\n            return false;\n        }\n        if (isPlainObject(value)) {\n            return getUnserializable(value, __spread(path, [key]));\n        }\n        return {\n            path: __spread(path, [key]),\n            value: value,\n        };\n    }, false);\n}\nfunction throwIfUnserializable(unserializable, context) {\n    if (unserializable === false) {\n        return;\n    }\n    var unserializablePath = unserializable.path.join('.');\n    var error = new Error(\"Detected unserializable \" + context + \" at \\\"\" + unserializablePath + \"\\\"\");\n    error.value = unserializable.value;\n    error.unserializablePath = unserializablePath;\n    throw error;\n}\n\nfunction createActiveRuntimeChecks(runtimeChecks) {\n    if (isDevMode()) {\n        if (runtimeChecks === undefined) {\n            console.warn('@ngrx/store: runtime checks are currently opt-in but will be the default in the next major version with the possibility to opt-out, see https://ngrx.io/guide/migration/v8 for more information.');\n        }\n        return __assign({ strictStateSerializability: false, strictActionSerializability: false, strictStateImmutability: false, strictActionImmutability: false }, runtimeChecks);\n    }\n    return {\n        strictStateSerializability: false,\n        strictActionSerializability: false,\n        strictStateImmutability: false,\n        strictActionImmutability: false,\n    };\n}\nfunction createSerializationCheckMetaReducer(_a) {\n    var strictActionSerializability = _a.strictActionSerializability, strictStateSerializability = _a.strictStateSerializability;\n    return function (reducer) {\n        return strictActionSerializability || strictStateSerializability\n            ? serializationCheckMetaReducer(reducer, {\n                action: strictActionSerializability,\n                state: strictStateSerializability,\n            })\n            : reducer;\n    };\n}\nfunction createImmutabilityCheckMetaReducer(_a) {\n    var strictActionImmutability = _a.strictActionImmutability, strictStateImmutability = _a.strictStateImmutability;\n    return function (reducer) {\n        return strictActionImmutability || strictStateImmutability\n            ? immutabilityCheckMetaReducer(reducer, {\n                action: strictActionImmutability,\n                state: strictStateImmutability,\n            })\n            : reducer;\n    };\n}\nfunction provideRuntimeChecks(runtimeChecks) {\n    return [\n        {\n            provide: _USER_RUNTIME_CHECKS,\n            useValue: runtimeChecks,\n        },\n        {\n            provide: USER_RUNTIME_CHECKS,\n            useFactory: _runtimeChecksFactory,\n            deps: [_USER_RUNTIME_CHECKS],\n        },\n        {\n            provide: _ACTIVE_RUNTIME_CHECKS,\n            deps: [USER_RUNTIME_CHECKS],\n            useFactory: createActiveRuntimeChecks,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createImmutabilityCheckMetaReducer,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createSerializationCheckMetaReducer,\n        },\n    ];\n}\nfunction _runtimeChecksFactory(runtimeChecks) {\n    return runtimeChecks;\n}\n\nvar StoreRootModule = /** @class */ (function () {\n    function StoreRootModule(actions$, reducer$, scannedActions$, store) {\n    }\n    StoreRootModule = __decorate([\n        NgModule({}),\n        __metadata(\"design:paramtypes\", [ActionsSubject,\n            ReducerObservable,\n            ScannedActionsSubject,\n            Store])\n    ], StoreRootModule);\n    return StoreRootModule;\n}());\nvar StoreFeatureModule = /** @class */ (function () {\n    function StoreFeatureModule(features, featureReducers, reducerManager, root) {\n        this.features = features;\n        this.featureReducers = featureReducers;\n        this.reducerManager = reducerManager;\n        var feats = features.map(function (feature, index) {\n            var featureReducerCollection = featureReducers.shift();\n            var reducers = featureReducerCollection /*TODO(#823)*/[index];\n            return __assign({}, feature, { reducers: reducers, initialState: _initialStateFactory(feature.initialState) });\n        });\n        reducerManager.addFeatures(feats);\n    }\n    StoreFeatureModule.prototype.ngOnDestroy = function () {\n        this.reducerManager.removeFeatures(this.features);\n    };\n    StoreFeatureModule = __decorate([\n        NgModule({}),\n        __param(0, Inject(_STORE_FEATURES)),\n        __param(1, Inject(FEATURE_REDUCERS)),\n        __metadata(\"design:paramtypes\", [Array, Array, ReducerManager,\n            StoreRootModule])\n    ], StoreFeatureModule);\n    return StoreFeatureModule;\n}());\nvar StoreModule = /** @class */ (function () {\n    function StoreModule() {\n    }\n    StoreModule.forRoot = function (reducers, config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: StoreRootModule,\n            providers: [\n                { provide: _INITIAL_STATE, useValue: config.initialState },\n                {\n                    provide: INITIAL_STATE,\n                    useFactory: _initialStateFactory,\n                    deps: [_INITIAL_STATE],\n                },\n                { provide: _INITIAL_REDUCERS, useValue: reducers },\n                {\n                    provide: _STORE_REDUCERS,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS,\n                },\n                {\n                    provide: INITIAL_REDUCERS,\n                    deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n                    useFactory: _createStoreReducers,\n                },\n                {\n                    provide: USER_PROVIDED_META_REDUCERS,\n                    useValue: config.metaReducers ? config.metaReducers : [],\n                },\n                {\n                    provide: _RESOLVED_META_REDUCERS,\n                    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n                    useFactory: _concatMetaReducers,\n                },\n                {\n                    provide: _REDUCER_FACTORY,\n                    useValue: config.reducerFactory\n                        ? config.reducerFactory\n                        : combineReducers,\n                },\n                {\n                    provide: REDUCER_FACTORY,\n                    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n                    useFactory: createReducerFactory,\n                },\n                ACTIONS_SUBJECT_PROVIDERS,\n                REDUCER_MANAGER_PROVIDERS,\n                SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n                STATE_PROVIDERS,\n                STORE_PROVIDERS,\n                provideRuntimeChecks(config.runtimeChecks),\n            ],\n        };\n    };\n    StoreModule.forFeature = function (featureName, reducers, config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: StoreFeatureModule,\n            providers: [\n                {\n                    provide: _FEATURE_CONFIGS,\n                    multi: true,\n                    useValue: config,\n                },\n                {\n                    provide: STORE_FEATURES,\n                    multi: true,\n                    useValue: {\n                        key: featureName,\n                        reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory\n                            ? config.reducerFactory\n                            : combineReducers,\n                        metaReducers: !(config instanceof InjectionToken) && config.metaReducers\n                            ? config.metaReducers\n                            : [],\n                        initialState: !(config instanceof InjectionToken) && config.initialState\n                            ? config.initialState\n                            : undefined,\n                    },\n                },\n                {\n                    provide: _STORE_FEATURES,\n                    deps: [Injector, _FEATURE_CONFIGS, STORE_FEATURES],\n                    useFactory: _createFeatureStore,\n                },\n                { provide: _FEATURE_REDUCERS, multi: true, useValue: reducers },\n                {\n                    provide: _FEATURE_REDUCERS_TOKEN,\n                    multi: true,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS,\n                },\n                {\n                    provide: FEATURE_REDUCERS,\n                    multi: true,\n                    deps: [\n                        Injector,\n                        _FEATURE_REDUCERS,\n                        [new Inject(_FEATURE_REDUCERS_TOKEN)],\n                    ],\n                    useFactory: _createFeatureReducers,\n                },\n            ],\n        };\n    };\n    StoreModule = __decorate([\n        NgModule({})\n    ], StoreModule);\n    return StoreModule;\n}());\nfunction _createStoreReducers(injector, reducers) {\n    return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\nfunction _createFeatureStore(injector, configs, featureStores) {\n    return featureStores.map(function (feat, index) {\n        if (configs[index] instanceof InjectionToken) {\n            var conf = injector.get(configs[index]);\n            return {\n                key: feat.key,\n                reducerFactory: conf.reducerFactory\n                    ? conf.reducerFactory\n                    : combineReducers,\n                metaReducers: conf.metaReducers ? conf.metaReducers : [],\n                initialState: conf.initialState,\n            };\n        }\n        return feat;\n    });\n}\nfunction _createFeatureReducers(injector, reducerCollection) {\n    var reducers = reducerCollection.map(function (reducer) {\n        return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n    });\n    return reducers;\n}\nfunction _initialStateFactory(initialState) {\n    if (typeof initialState === 'function') {\n        return initialState();\n    }\n    return initialState;\n}\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n    return metaReducers.concat(userProvidedMetaReducers);\n}\n\n/**\n * @description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param args `ActionCreator`'s followed by a state change function.\n *\n * **To maintain type-safety**: pass 10 or less `ActionCreator`'s.\n * @returns an association of action types with a state change function.\n */\nfunction on() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var reducer = args.pop();\n    var types = args.reduce(function (result, creator) { return __spread(result, [creator.type]); }, []);\n    return { reducer: reducer, types: types };\n}\n/**\n * @description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param ons Associations between actions and state changes.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`).  Cannot be used with class-based action creators.\n * - An action type should only be associated with at most one state change function, similar to switch statements.\n *   - In the case this is violated, the latest defined associated will be used (the latest `on` function passed).\n * - The returned `ActionReducer` should additionally be returned from an exported `reducer` function.\n * This is because [function calls are not supported](https://angular.io/guide/aot-compiler#function-calls-are-not-supported) by the AOT compiler.\n *\n * **Declaring a reducer creator with an exported reducer function**\n *\n * ```ts\n * const featureReducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n *\n * export function reducer(state: State | undefined, action: Action) {\n *   return featureReducer(state, action);\n * }\n * ```\n */\nfunction createReducer(initialState) {\n    var e_1, _a, e_2, _b;\n    var ons = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        ons[_i - 1] = arguments[_i];\n    }\n    var map = new Map();\n    try {\n        for (var ons_1 = __values(ons), ons_1_1 = ons_1.next(); !ons_1_1.done; ons_1_1 = ons_1.next()) {\n            var on_1 = ons_1_1.value;\n            try {\n                for (var _c = __values(on_1.types), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var type = _d.value;\n                    map.set(type, on_1.reducer);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (ons_1_1 && !ons_1_1.done && (_a = ons_1.return)) _a.call(ons_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return function (state, action) {\n        if (state === void 0) { state = initialState; }\n        var reducer = map.get(action.type);\n        return reducer ? reducer(state, action) : state;\n    };\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ACTIONS_SUBJECT_PROVIDERS as ɵngrx_modules_store_store_c, REDUCER_MANAGER_PROVIDERS as ɵngrx_modules_store_store_d, _runtimeChecksFactory as ɵngrx_modules_store_store_bb, createActiveRuntimeChecks as ɵngrx_modules_store_store_x, createImmutabilityCheckMetaReducer as ɵngrx_modules_store_store_z, createSerializationCheckMetaReducer as ɵngrx_modules_store_store_y, provideRuntimeChecks as ɵngrx_modules_store_store_ba, SCANNED_ACTIONS_SUBJECT_PROVIDERS as ɵngrx_modules_store_store_e, isEqualCheck as ɵngrx_modules_store_store_f, STATE_PROVIDERS as ɵngrx_modules_store_store_g, STORE_PROVIDERS as ɵngrx_modules_store_store_b, _concatMetaReducers as ɵngrx_modules_store_store_w, _createFeatureReducers as ɵngrx_modules_store_store_u, _createFeatureStore as ɵngrx_modules_store_store_t, _createStoreReducers as ɵngrx_modules_store_store_s, _initialStateFactory as ɵngrx_modules_store_store_v, _ACTIVE_RUNTIME_CHECKS as ɵngrx_modules_store_store_r, _FEATURE_CONFIGS as ɵngrx_modules_store_store_m, _FEATURE_REDUCERS as ɵngrx_modules_store_store_l, _FEATURE_REDUCERS_TOKEN as ɵngrx_modules_store_store_o, _INITIAL_REDUCERS as ɵngrx_modules_store_store_j, _INITIAL_STATE as ɵngrx_modules_store_store_h, _REDUCER_FACTORY as ɵngrx_modules_store_store_i, _RESOLVED_META_REDUCERS as ɵngrx_modules_store_store_p, _STORE_FEATURES as ɵngrx_modules_store_store_n, _STORE_REDUCERS as ɵngrx_modules_store_store_k, _USER_RUNTIME_CHECKS as ɵngrx_modules_store_store_q, createAction, props, union, Store, select, combineReducers, compose, createReducerFactory, ActionsSubject, INIT, ReducerManager, ReducerObservable, ReducerManagerDispatcher, UPDATE, ScannedActionsSubject, createSelector, createSelectorFactory, createFeatureSelector, defaultMemoize, defaultStateFn, resultMemoize, State, StateObservable, reduceState, INITIAL_STATE, REDUCER_FACTORY, INITIAL_REDUCERS, STORE_FEATURES, META_REDUCERS, FEATURE_REDUCERS, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, StoreModule, StoreRootModule, StoreFeatureModule, on, createReducer };\n//# sourceMappingURL=store.js.map\n"],"sourceRoot":""}